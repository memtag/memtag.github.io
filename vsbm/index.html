<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="user-scalable=no">
<title>volumeshader_bm</title>
<style>
body {
    background: #131115;
    overflow: hidden;
    margin: 0;
}
#c1 {
    position: fixed;
    left: 0px;
    top: 0px;
}
#main {
    transform-origin: 0px 0px;
    position: fixed;
    left: 0px;
    top: 0px;
}
</style>
</head>
<body>
<div id="main">
<canvas id="c1" width="1024" height="1024"></canvas>
</div>
<script>
var cx, cy;
var glposition, glright, glforward, glup, glorigin, glx, gly, gllen;
var canvas, gl;
var t1 = new Date().getTime();
var mx=0, my=0, mx1=0, my1=0, lasttimen=0;
var ml=0, mr=0, mm=0;
var len = 1.6;
var ang1 = 2.8;
var ang2 = 0.4;
var cenx = 0.0, ceny = 0.0, cenz = 0.0;

// Дуже щільний KERNEL з 15 ітераціями
var KERNEL = "float kernal(vec3 ver){\n" +
"   vec3 a = ver;\n" +
"   float b,c,d,e;\n" +
"   for(int i=0;i<15;i++){\n" +
"       b=length(a);\n" +
"       c=atan(a.y,a.x)*32.0;\n" +
"       d=acos(a.z/b)*32.0;\n" +
"       b=pow(b,32.0);\n" +
"       a=vec3(b*sin(d)*cos(c),b*sin(d)*sin(c),b*cos(d))+ver;\n" +
"       if(b>6.0){ break; }\n" +
"   }\n" +
"   return 4.0-a.x*a.x-a.y*a.y-a.z*a.z;\n" +
"}";

function ontimer(){ ang1+=0.01; draw(); window.requestAnimationFrame(ontimer); }

// --- Події миші та сенсора ---
document.addEventListener("mousedown", function(ev){ var e=ev||event; if(e.button==0) ml=1; if(e.button==2) mr=1; mx=e.clientX; my=e.clientY; }, false);
document.addEventListener("mouseup", function(ev){ var e=ev||event; if(e.button==0) ml=0; if(e.button==2) mr=0; }, false);
document.addEventListener("mousemove", function(ev){
    var e=ev||event;
    if(ml==1){ ang1+=(e.clientX-mx)*0.002; ang2+=(e.clientY-my)*0.002; if(e.clientX!=mx||e.clientY!=my) mm=1;}
    if(mr==1){
        var l=len*4.0/(cx+cy);
        cenx+=l*(-(e.clientX-mx)*Math.sin(ang1)-(e.clientY-my)*Math.sin(ang2)*Math.cos(ang1));
        ceny+=l*((e.clientY-my)*Math.cos(ang2));
        cenz+=l*((e.clientX-mx)*Math.cos(ang1)-(e.clientY-my)*Math.sin(ang2)*Math.sin(ang1));
        if(e.clientX!=mx||e.clientY!=my) mm=1;
    }
    mx=e.clientX; my=e.clientY;
}, false);
document.addEventListener("mousewheel", function(ev){ ev.preventDefault(); var e=ev||event; len*=Math.exp(-0.001*e.wheelDelta); }, false);

// --- Клавіші та сенсор ---
document.addEventListener("touchstart", function(ev){
    var n=ev.touches.length;
    if(n==1){ var e=ev.touches[0]; mx=e.clientX; my=e.clientY; }
    else if(n==2){ var e=ev.touches[0]; mx=e.clientX; my=e.clientY; e=ev.touches[1]; mx1=e.clientX; my1=e.clientY; }
    lasttimen=n;
}, false);
document.addEventListener("touchend", function(ev){
    var n=ev.touches.length;
    if(n==1){ var e=ev.touches[0]; mx=e.clientX; my=e.clientY; }
    else if(n==2){ var e=ev.touches[0]; mx=e.clientX; my=e.clientY; e=ev.touches[1]; mx1=e.clientX; my1=e.clientY; }
    lasttimen=n;
}, false);
document.addEventListener("touchmove", function(ev){
    ev.preventDefault();
    var n=ev.touches.length;
    if(n==1&&lasttimen==1){ var e=ev.touches[0]; ang1+=(e.clientX-mx)*0.002; ang2+=(e.clientY-my)*0.002; mx=e.clientX; my=e.clientY; }
    else if(n==2){
        var e=ev.touches[0], e1=ev.touches[1];
        var l=len*2.0/(cx+cy), l1;
        cenx += l*(-(e.clientX+e1.clientX-mx-mx1)*Math.sin(ang1)-(e.clientY+e1.clientY-my-my1)*Math.sin(ang2)*Math.cos(ang1));
        ceny += l*((e.clientY+e1.clientY-my-my1)*Math.cos(ang2));
        cenz += l*((e.clientX+e1.clientX-mx-mx1)*Math.cos(ang1)-(e.clientY+e1.clientY-my-my1)*Math.sin(ang2)*Math.sin(ang1));
        l1=Math.sqrt((mx-mx1)*(mx-mx1)+(my-my1)*(my-my1)+1.0);
        mx=e.clientX; my=e.clientY; mx1=e1.clientX; my1=e1.clientY;
        l=Math.sqrt((mx-mx1)*(mx-mx1)+(my-my1)*(my-my1)+1.0);
        len*=l1/l;
    }
    lasttimen=n;
}, false);

document.oncontextmenu=function(event){ if(mm==1) event.preventDefault(); };

function draw(){
    gl.uniform1f(glx, cx*2.0/(cx+cy));
    gl.uniform1f(gly, cy*2.0/(cx+cy));

    // Малюємо кілька копій головної фігури
    for(var fx=-0.8; fx<=0.8; fx+=0.4){
        for(var fy=-0.8; fy<=0.8; fy+=0.4){
            gl.uniform1f(gllen, len*0.25); // зменшена довжина для внутрішніх копій
            gl.uniform3f(glorigin, len*Math.cos(ang1)*Math.cos(ang2)+cenx+fx, len*Math.sin(ang2)+ceny+fy, len*Math.sin(ang1)*Math.cos(ang2)+cenz);
            gl.uniform3f(glright, Math.sin(ang1),0,-Math.cos(ang1));
            gl.uniform3f(glup, -Math.sin(ang2)*Math.cos(ang1),Math.cos(ang2),-Math.sin(ang2)*Math.sin(ang1));
            gl.uniform3f(glforward, -Math.cos(ang1)*Math.cos(ang2),-Math.sin(ang2),-Math.sin(ang1)*Math.cos(ang2));
            gl.drawArrays(gl.TRIANGLES,0,6);
        }
    }
    gl.finish();
}

window.onresize=window.onload=function(){
    cx=document.body.clientWidth; cy=document.body.clientHeight;
    if(cx>cy) cx=cy; else cy=cx;
    document.getElementById("main").style.width="1024px";
    document.getElementById("main").style.height="1024px";
    document.getElementById("main").style.transform="scale("+cx/1024+","+cy/1024+")";
};

window.onload=function(){
    cx=document.body.clientWidth; cy=document.body.clientHeight;
    if(cx>cy) cx=cy; else cy=cx;
    document.getElementById("main").style.width="1024px";
    document.getElementById("main").style.height="1024px";
    document.getElementById("main").style.transform="scale("+cx/1024+","+cy/1024+")";

    var positions=[-1.0,-1.0,0.0,1.0,-1.0,0.0,1.0,1.0,0.0,-1.0,-1.0,0.0,1.0,1.0,0.0,-1.0,1.0,0.0];
    var VSHADER_SOURCE = "#version 100\nprecision highp float;\nattribute vec4 position;\nvarying vec3 dir, localdir;\nuniform vec3 right, forward, up, origin;\nuniform float x,y;\nvoid main(){gl_Position=position;

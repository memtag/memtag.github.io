<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fun Timer</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:#0f172a;color:#e6eef8; }
  .card { background:#091127;padding:24px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,.6);width:320px;text-align:center; }
  input,button { font:inherit;padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:transparent;color:inherit }
  #count{font-size:2rem;margin:14px 0}
  .notice{font-size:.85rem;color:#9fb0d1;margin-top:8px}
</style>
</head>
<body>
  <div class="card">
    <h2>Fun Timer</h2>
    <div id="info">Use parameter <code>?time=1m</code></div>
    <div id="count">â€”</div>
    <div style="margin:12px 0">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>
    <div class="notice" id="notice">You will get a short sound after the timer.</div>
  </div>

<script>
(async function(){
  function parseTimeParam(str) {
    if (!str) return null;
    const m = str.trim().match(/^(\d+)([smh]?)$/i);
    if (!m) return null;
    const v = Number(m[1]);
    const u = (m[2]||'s').toLowerCase();
    if (u === 'h') return v * 3600 * 1000;
    if (u === 'm') return v * 60 * 1000;
    return v * 1000;
  }

  const params = new URLSearchParams(window.location.search);
  const timeParamRaw = params.get('time') || params.get('t') || '';
  const delayMs = parseTimeParam(timeParamRaw);

  const countEl = document.getElementById('count');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const notice = document.getElementById('notice');

  if (!delayMs) {
    countEl.textContent = 'Invalid or missing time parameter';
    startBtn.disabled = true;
    return;
  }

  function human(ms) {
    if (ms >= 3600_000) return (ms/3600_000)+'h';
    if (ms >= 60_000) return (ms/60000)+'m';
    return (ms/1000)+'s';
  }
  document.getElementById('info').textContent = `Timer: ${human(delayMs)}`;

  let audioCtx = null;
  let sourceNode = null;
  let gainNode = null;
  let filter = null;
  let playBuffer = null;

  async function fetchAudioBuffer(url) {
    const res = await fetch(url);
    const ab = await res.arrayBuffer();
    return await audioCtx.decodeAudioData(ab);
  }

  function playWithBassBoost(buffer) {
    if (!audioCtx) return;
    stopPlayback();
    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = buffer;
    filter = audioCtx.createBiquadFilter();
    filter.type = 'lowshelf';
    filter.frequency.value = 150;
    filter.gain.value = 10;
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 1.0;
    sourceNode.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    sourceNode.start();
    sourceNode.onended = () => { stopPlayback(); };
  }

  function stopPlayback() {
    try {
      if (sourceNode) { sourceNode.stop(); sourceNode.disconnect(); sourceNode = null; }
      if (filter) { filter.disconnect(); filter = null; }
      if (gainNode) { gainNode.disconnect(); gainNode = null; }
    } catch(e){}
  }

  let timerId = null;
  let intervalId = null;
  let targetTime = null;

  function updateCountdown() {
    const rem = Math.max(0, Math.ceil((targetTime - Date.now())/1000));
    countEl.textContent = rem + 's';
    if (rem <= 0) {
      clearInterval(intervalId); intervalId = null;
    }
  }

  async function onTimerFinish() {
    const ok = confirm('Ready? A sound will play soon.');
    if (!ok) {
      countEl.textContent = 'Canceled';
      return;
    }

    if (!playBuffer) {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.value = 120;
      g.gain.value = 0;
      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start();
      g.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 0.05);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3.5);
      osc.stop(audioCtx.currentTime + 3.6);
      countEl.textContent = 'ðŸ”Š Playing...';
      return;
    }

    playWithBassBoost(playBuffer);
    countEl.textContent = 'ðŸ”Š Playing...';
  }

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    stopBtn.disabled = false;
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      try {
        playBuffer = await fetchAudioBuffer('beep.mp3');
      } catch(e) {}
    }

    const consent = confirm(`A sound will play after ${human(delayMs)}. Start timer?`);
    if (!consent) {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      countEl.textContent = 'Canceled';
      return;
    }

    targetTime = Date.now() + delayMs;
    updateCountdown();
    intervalId = setInterval(updateCountdown, 1000);
    timerId = setTimeout(async () => {
      await onTimerFinish();
    }, delayMs);

    notice.textContent = 'Timer running. Keep tab active.';
  });

  stopBtn.addEventListener('click', () => {
    if (timerId) clearTimeout(timerId);
    if (intervalId) clearInterval(intervalId);
    timerId = intervalId = null;
    stopPlayback();
    countEl.textContent = 'Stopped';
    startBtn.disabled = false;
    stopBtn.disabled = true;
    notice.textContent = 'Timer stopped.';
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      notice.textContent = 'Tab hidden â€” timer may pause.';
    } else {
      notice.textContent = 'Tab active.';
    }
  });
})();
</script>
</body>
</html>
